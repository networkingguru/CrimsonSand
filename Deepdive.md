# Deep dive into the combat system

![](F:\Docs\GitHub\CrimsonSand\2021-08-25 09-33-37.gif)



So, as one of my (actual) engineer friends said: 'The best documentation is the code'. So I am going to try and explain this using the code at present, as some of the things in the original rules system didn't work, and some just showed flaws that I corrected when I implemented them in the CRPG.

First, you need to look at combatcontrol.py. Basically, this is where all the combat goes; it's a simple fall-through if-then list of things to do in combat. Here's how it works:

1.  If there's a pause, display the pause screen

2.  If we are in the explore phase (i.e. not combat), then move the actor by one space in whatever direction the player wants.

3.  If we are in the initialization phase (which happens as soon as we see an opponent - or they see us), figure out initiative:

    a.  This is done in phase_init in the combat_phases.py file. It then calls turn_order in combat_functions.py, which basically orders all entities by initiative score (fighter.init, which is determined based on the following formula from fighter.py: men+(swift/4)+sens+(best_combat_skill/4)+random(1-100)).

    b.  Initiative is ordered from highest to lowest.

4.  Next, we go to the action phase, phase_action in combat_phases.py. This has a simple routine to see if there are enemies in the current actor's area of control (AOC). AOC is defined by the reach of the weapon, and is displayed on screen as a colored band (green for the player, red for the enemy). If you are not in an enemy's AOC, you can move the actor however you like. However, if anyone is in anyone else's AOC, we initiate combat. I know this seems weird because we did initiative last step, but think about it this way: We have to figure out turn order regardless of whether we are fighting or not. All actors get to move even if they are all buddies.

5.  Init_combat is the base 'player control' function. This is where the player decides to wait, maneuver, change stance or guard, attack, move, or end turn. Maneuver, attack, and move will all cost AP. AP is Action Points, and they are effectively how much time a character is given in a turn. Every action costs a certain amount of AP. The AP a player has is totally determined by the swiftness attribute, as defined in fighter.py (self.max_ap). The AP required to perform most actions is based on the stance. For example, if you are standing, the AP to walk is based on your movement rate (self.mv in fighter.py), which is based on self.max_mv, which in turn is based on the character's height, weight, swiftness, and flexibility attributes. Attacking requires AP that is based on the weapon itself, with the core rules contained in weapon.py. Basically, you have a weapon class, which contains attacks. Since weapons are all bespoke (there's basically no possibility of getting the same weapon twice, it's just too unlikely), the AP for each attack is also bespoke. Each weapon has a certain number of attacks, but they require AP depending on the weight of the weapon itself, along with the attack (for example, a 1H slash has a base AP of 15). The code allows all fighters to make one attack per round regardless of AP, but more than one is dependent on your stats. For example, if the attack costs 15 AP and you only have 12, you can still attack. But if you have 46 AP, you can attack three times.\
    Keep in mind that most of these phases are simply methods to determine what the valid menu choices are. Phase_action is the most basic: Are we fighting, or not?

6.  Phase_weapon is the first proper combat phase. Here, the code examines your weapons and determines which of them can actually attack (which ones are valid in code terms) based on the algorithm contained in the function attack_filter. The main thing attack_filter does is determine, based on reach and which hand you are using, whether or not you can physically hit the opponent. If so, it returns a Boolean value of True, which means there's at least one attack you can use. If the attack is valid, the code calcs some stats and adds the weapon and the best attack stats to a dictionary which is then turned into a list and presented to the user in order to pick a weapon to attack with (the AI goes through the same process to determine valid attacks, minus the UI elements).

7.  Phase_option's purpose is to present you with a list of valid attacks that you can choose with the weapon you have already chosen to attack the opponent with. It uses the same attack_filter function to find valid attacks with the chosen weapon, then compiles statistics and presents them to you in the list of valid attacks. The goal is to give the player (and AI) the best information in order to make a valid decision.

8.  Phase_location's goal is to get the player to commit to a hit location to target. At this point, the player (or AI) has chosen the weapon and attack, so now they need to choose where they are aiming for on the opponent's body. They will hit if they succeed and the opponent does not successfully block or dodge. If they miss by a small margin, they will hit a nearby location, and if they miss by a large margin, they simply miss. This function also tries to present the actor with information about the opponent's injuries, since that is of strategic importance.

9.  Phase_option2's goal is to get the player to commit to an angle of attack. The angle has some significant affects on damage, the ability to dodge, and the ability to block depending on the weapon. For example, a sword thrust is easier to dodge than a slash. Also, it has some impact on the damage. An overhand slash from a sword has the entire weight of the actor behind it, while a horizontal slash has the power of the actor's hips behind it (think about the power in a major league home run swing). A thrust has none of these, but has a mechanical advantage because of the force multiplier of the point of the sword. This function doesn't determine these things, but it tries to present them in a reasonable way to the actor, using damage, to hit, parry mod, and dodge mod descriptors (all entered into a dictionary then converted to a list by UI functions).\
    Angle is (currently) listed based on cardinal directions, numbered clockwise.\
    NW N NE\
    W E\
    SW S SE\
    1 is N-\>S, which means the swing begins directly overhead and continues directly down.\
    2 is NE-\>SW, which means the swing begins at the upper right of the attacker, and continues down to the lower left.\
    And so on...\
    These angles are important, because they also determine pass-through damage; i.e. when an attack is damaging enough to destroy or pass through a location, where does it hit next? Also, angles are used to determine if a location is valid for the attack. For instance, you can't uppercut the top of someone's head.

10. Phase_confirm presents the options the actor has chosen and asks them to confirm or decline the attack. If they confirm, it also carries out the attack using the function perform_attack. Perform_attack sees if the attack hits (using make_attack_roll), if it does, determines damage (using damage_controller) and then sees if the attack is repeatable (which is a convenience function for the player).\
    Note that there is also an opportunity for the opponent to dodge or parry, if he has enough AP to do so. This is not covered here because the process differs depending on if it's an AI actor or a player. If it's a player, there's a whole phase for making that choice, which will be covered later. AI will simply choose whichever has the highest chance of success.

    a.  Damage_controller handles what is probably the most complex part of the game. First, using the attack angle and relative positioning of the actors, it determines the relative angle between the two using the function entity_angle. Then, it calculates the percentages for deflection and soaking damage using the function calc_damage_soak. Deflection is the chance to deflect, or completely avoid damage. There are three different primary damage types ((p)eircing, (s)lashing, and (b)ludgeoning), and each has different deflection rates based on the armor. For example, a plate helmet has a very high deflection rate vs. piercing. Since the armor is all bespoke, I can't give exact figures, but from my example armor_gen.txt, the Poor Steel Double-walled Plate Spaulder has B/S/P Deflect Percentages of 22.0%/50.0%/104.0%. However, this doesn't ensure that P attacks will always be deflected, because armor also has a deflect maximum. This models the fact that a piercing weapon with enough force will overcome the tendency to be deflected (an extreme example would be a bullet, which punches through even plate armor when it has enough force). In my example from armor_gen, the Spaulder has B/S/P Deflect Maximums of 218465/43693/43693 PSI, respectively.\
        Soak, on the other hand, is the percentage of damage that is absorbed by the armor, meaning neither the armor nor the actor takes that damage. Soak is only valid for B damage, and it models the absorption properties of soft armors vs. blunt trauma.\
        However, calc_damage_soak does not calculate armor's deflect or soak percentages, it calculates the actor's *body's* deflect and soak. Each hit location is divided into three components, skin, tissue, and bone, each of which has its own deflect and soak percentages. These numbers *are* hard -coded, more or less, but are modified by various attributes (bodyfat, muscle mass, skin thickness, and flexibility). The base values for each, along with their modifiers, can be seen in the function.\
        Once all this is figured out, damage_controller gets into the main damage loop, which continues until there is either no more damage to apply, or no more hit locations in the path. First, it figures out what to do with armor by using the function armor_control. The first thing this function does is determine if the armor is rigid or not. If it is, then some of the damage will be converted to bludgeoning (even for slashing and piecing weapons) and displaced to other hit locations. This is because the rigid armor, as part of its design, spreads the force over the surface of many interlocking plates. So it blunts even s and p attacks that it does not deflect entirely. Anyway, this process is handled by the armor_displace function. Then it goes into the armor_protect function, which determines how much the armor is going to protect the actor. This function first sees if the damage inflicted is over the deflect maximum PSI. If it is not, it rolls against the deflect percentage. It then determines how much damage gets through the armor, subtracts the amount of total damage (if the armor blocked all damage) or the maximum amount the armor could block (if the armor was penetrated) from the 'hits' of the armor itself (damaging the armor), and then returns the damage type and amount.\
        Once this is all done, back in damage_controller, we get to the dam_loop function. This function figures out how much damage was deflected or soaked by the actor's body using the calc_layer_damage function.\
        It is important to note that each damage type is applied differently. S and P damage is applied to layers in order, skin-\>tissue-\>bone. In order to do S or P damage to tissue, you must first completely destroy the skin layer. So if an S or P weapon actually gets to bone, both skin and tissue are destroyed in that location. If an S weapon gets through the bone, the location has been severed. If it then still has damage to spend, it will immediately attack the next location in line. P damage will probably never destroy bone, but if it gets that deep, whether deflected or not, it will attempt to 'run through' the character. For example, if you pierce an actor's left chest from the left side, it will continue on to the right chest cavity. B damage, on the other hand, applies its damage simultaneously to all three hit layers. If B damage crushes the bone, it will also follow through to the next location.\
        Once damage to each location has been determined, now we have to get and apply injury effects, which is done using the get_injuries function. Injuries occur when damage passes certain percentage thresholds on each layer (see find_dam_threshold). When this happens, the loop in get_injuries finds (using filter_injuries) and applies (using apply_injuries) these injuries to the actor.\
        Injuries are intricate, but are all based off of the Injury base class in injuries.py. It is the template that defines the filter parameters (hit locations, prerequisite injuries, threshold, damage types, etc) as well as the downsides of getting the injury. It also includes two helper methods for filling out descriptions dynamically. The individual injury classes are subclasses of the Injury base class, which allows me to use itersubclasses to get a dynamic list of all of the injuries (this is a technique I use a lot for many things). The individual injuries are all contained in injuries.py, under the master class. They range from light scraping to partial decapitation. There's a fair bit of variety.\
        Once injuries have been filtered and applied to all necessary locations, dam_loop calls another helper function, handle_mobility_change, to see if the actor has been rendered prone, unable to run, unable to walk, etc, and applies those effects. Then it returns control back to damage_controller. Damage_controller then removes any weapons that were attached to limbs that have now been severed, checks to see if the actor has been sliced in two (using cleave_checker), and handles death and unconsciousness (using handle_state_change). It then returns back to perform_attack, which returns it back to phase_confirm.\
        One thing to note, if the attack missed, the attacker is in his opponent's area of control (AOC), and the opponent has enough AP to counterattack, then the opponent is offered that opportunity. After the counterattack, the round returns to the original attacker's control. This is a single counterattack opportunity that occurs whenever anyone misses, and it reflects the risk you are under by being off balance after missing.

11. Phase_repeat is simply a convenience phase for the player, allowing them to repeat the last attack if possible (skipping all of the previous phases).

12. Phase_defend is a special phase that is only entered when the AI attacks the player. In this case, the player is presented with a special menu to choose his defense method. It uses the function find_defense_probability to present the player with *approximate* chances of dodging, parrying, or blocking the blow. It's important to note that both the player and AI are presented with these same numbers, so neither has perfect information.\
    The difference between a parry and a block is: Blocking is easier, but the item you block with (shield, weapon, forearm, etc) takes the brunt of the damage. Parrying is harder, but harmlessly deflects the blow if successful.\
    In some cases, the defender can also auto block. Auto block is when your defensive stance automatically blocks the damage to that location. A simple example is of a warrior with a kite shield held in the left arm. The shield will effectively block the warrior's upper body below the neck without any effort on the warrior's part. A more complex example would be the conventional boxing guard, which autoblocks both left and right ribs due to the positioning of the forearms.\
    Guards are individually defined as subclasses of the Guard class, and contained in weapon.py, along with the main Weapon class, all of the weapon subclasses, the main Attack class, and all of its subclasses.\
    The bulk of phase_defend handles determination of the success or failure of the defense, and dealing with the ramifications of that.

13. Phase_disengage is a special phase only entered into if the player chooses to disengage from an opponent's area of control (AOC). It determines what directions you can legally disengage from, whether or not the opponent can take his opportunity attack, and the completion of that attack. If the player successfully disengages, the player is back to a movement phase, and can flee freely until they run out of AP.

14. Phase_move is the movement phase. This is a different phase because the player is not presented with a menu during this phase. He simply uses the number pad or arrow keys to move, up to the limit of his AP. If he enters an opponent's AOC, movement phase automatically ceases, and action phase begins (presenting a menu).\
    Since the game uses a 180-degree FOV, the actor's facing is also important, and the ability to spin as well as strafe has been implemented. Spinning occurs using the "," and "." keys, and allows you to rotate the actor counterclockwise or clockwise, respectively. Strafe mode makes the player face the enemy, no matter what his direction of travel. It is a toggle that is set or released by pressing the ";" key.

15. Phase_maneuver is responsible for allowing the player to choose a combat maneuver. A combat maneuver is something other than directly hitting the opponent. It can be a simple as a push, or as complex as a joint lock. Maneuvers are similar to attacks in that they are defined by a main Maneuver class (in maneuver.py), and all of the individual maneuvers are subclasses. Maneuvers require a certain skill, have modifiers to the base roll, counter rolls, dodge rolls, escape rolls, and reversal rolls, a list of counter maneuvers, a list of locations it can target and cannot target, and a length definition, used to see if the maneuver can reach the target (for example, a 4-foot-tall fighter should not be able to headbutt the forehead of a 7-foot-tall fighter).\
    The function that determines which maneuvers can be performed, as well as which hit locations each one can target, is valid_maneuvers, in combat_fuctions.py. It's complex, but pretty well commented. It returns a list with each of the valid maneuvers.\
    This phase is also the phase where the player can choose to perform a special maneuver, a feint and counter. If they chose to do this, they switch to phase_feint.

16. Phase_feint is responsible for setting up a feint. Basically, the player sacrifices some AP to leave an opening in their defenses. The player then adds 33% of their best combat skill to their dodge and parry options for attacks to that location. This information is not given to the opponent (AI). They AI and player then perform a contested roll to see if the AI is fooled. This is done using the save_roll_con function in utilities.py, which basically rolls against their attributes (their respective best combat skills, in this case) and figures out who had the best margin of success. If the player wins this, the AI is then presented with a (deceptive) bonus to hit that location. If it chooses to attack, it actually has a lower bonus to hit by 50%, *and* the player has a bonus to dodge and parry. The goal is to get the AI to miss to allow a follow-up attack, but even barring that, the player is in minimal danger due to the bonus to dodge and parry. Typically, with a very skilled AI, this simply wastes AP for the player (since the AI uses the player's AP to attack).

17. Phase_stance is where the actor gets to adjust their fighting stance. Fighting stance is defined along four axis: Width (open or closed), which defines how much of you faces the opponent, length (long or short), which defines how far apart your legs are placed and determines agility and stability, height (high or low) which is how 'tall' you are standing and trades off between power and mobility, and weight (front, neutral, and rear), which is which leg your weight is concentrated on, which trades off between power and defense. For more detail on stances, see [Stance (martial arts) - Wikipedia](https://en.wikipedia.org/wiki/Stance_(martial_arts)). Changing stance is free (no AP cost) and the effects of the stance are applied as global modifiers to stability, dodge, and damage.

18. Phase_guard is where the actor can change their guard. Each weapon has built-in guard styles pulled from training manuals on said weapons, all detailed in weapon.py. For example, under the guards section of the Unarmed class in weapon.py, you'll find conventional, southpaw, high, low, half guard-left lead, and half guard-right lead. Each guard provides the following stats:\
    Location hit modifiers: Each guard is better or worse at protecting specific parts of the body. These are expressed as modifiers to hit certain locations.\
    Dodge and parry mods: Each guard makes it more or less difficult to dodge and parry.\
    To-hit mods: Each guard can help or hinder your ability to hit an opponent.\
    Required locations: These are the locations that must be functional (i.e. not paralyzed or severed) in order to use the guard.\
    Auto-block locations: These are the locations the guard automatically blocks, as mentioned in a previous section.\
    Like stance, changing guard is free, and the effects apply immediately.

19. Grappling phases: Phase_grapple, phase_grapple_defense, and phase_grapple_confirm are all phases to handle the intricacies of grappling, including reversals and counters. Phase_grapple is where you choose the body part to use the maneuver you selected earlier on. Phase_grapple confirm is where you confirm your choices. And phase_grapple_defense is the highly complex phase (that really should be broken up into more functions) that handles defending.\
    Basically, it first figures out what skill the attacker is using, then it figures out what the location modifiers are. Next, it looks at the defender's skills to figure out what the best skill for countering/reversing are, and finds a list of valid maneuvers for countering and reversing using the valid_maneuvers function. Then it figures out what the chances are for dodging, countering, and reversing for the defender. Once that is done, it normalizes the chances (placing them in a 0-99 scale to get rid of negative or 100+% chances), and creates the help test to tell the user what these are. Then it presents the defender with their defense choices.\
    When a choice is made, a contested roll is used to see if it succeeds, and the result is applied (removing any necessary AP in the process).
